#!/bin/zsh

# Provide functionality for git repositories

typeset -gA git_info
git_info=()

# Cache relevant git information
git_update_info() {
    # print "git_update_info"
    git_info=()

    local gitdir="$(git rev-parse --git-dir 2>/dev/null)"

    if [ $? -ne 0 ] || [ -z "$gitdir" ]; then
	return
    fi

    git_info[dir]=$gitdir
    git_info[bare]=$(git rev-parse --is-bare-repository)
    git_info[inwork]=$(git rev-parse --is-inside-work-tree)
}

# Is the current directory a git directory?
git_is_git() {
    # print "git_is_git"
    if [ -z "$git_info[dir]" ]; then
	return 1
    else
	return 0
    fi
}

# Are we within a git working tree?
git_is_in_work_tree() {
    # print "git_is_in_work_tree"
    git_is_git || return
    if [ "$git_info[inwork]" = "true" ]; then
	return 0
    else
	return 1
    fi
}

# Are we within a bare repository?
git_is_bare() {
    # print "git_is_bare"
    git_is_git || return
    if [ "$git_info[bare]" = "true" ]; then
	return 0
    else
	return 1
    fi
}

git_head() {
    # print "git_head"
    git_is_git || return 1

    if [ -z "$git_info[head]" ]; then
	local name=$(git symbolic-ref -q HEAD)
	if [ $? -eq 0 ]; then
	    if [[ $name == refs/(heads|tags)/* ]]; then
		name=${name#refs/(heads|tags)/}
	    fi
	else
	    name=$(git name-rev --name-only --no-undefined --always HEAD)
	    if [ $? -ne 0 ]; then
		return 1
	    elif [[ $name == remotes/* ]]; then
		name=${name#remotes/}
	    fi
	fi
	git_info[head]=$name
    fi

    echo $git_info[head]
}

# Prints the name of the current branch (HEAD)
git_branch() {
    # print "git_branch"
    git_is_git || return 1
    git_is_bare && return 1

    if [ -z "$git_info[branch]" ]; then
	local branch=$(git symbolic-ref HEAD 2>/dev/null)
	if [ $? -eq 0 ]; then
	    branch=${branch##*/}
	else
	    branch=$(git name-rev --name-only --always HEAD)
	fi
	git_info[branch]=$branch
    fi
    
    echo $git_info[branch]
    return 0
}

git_is_index_clean() {
    git_is_git || return 1
    if git diff --quiet --cached 2>/dev/null; then
	return 0
    else
	return 1
    fi
}
 
git_is_work_tree_clean() {
    git_is_git || return 1
    if git diff --quiet 2>/dev/null; then
	return 0
    else
	return 1
    fi
}

git_has_untracked() {
    # print "git_has_untracked"
    git_is_git || return 1
    local -a flist
    flist=($(git ls-files --others --exclude-standard))
    if [ $#flist -gt 0 ]; then
	return 0
    else
	return 1
    fi
}

git_has_unmerged() {
    # print "git_has_unmerged"
    local -a flist
    flist=($(git ls-files -u))
    if [ $#flist -gt 0 ]; then
	return 0
    else
	return 1
    fi
}

git_chpwd_hook() {
    # print "git_chpwd_hook"
    git_update_info
}
 
git_preexec_hook() {
    # print "git_preexec_hook"
    if [[ $2 == git\ * ]] || [[ $2 == *\ git\ * ]]; then
	git_precmd_do_update=1
    fi
}
 
git_precmd_hook() {
    # print "git_precmd_hook"
    if [ $git_precmd_do_update ]; then
	unset git_precmd_do_update
	git_update_info
    fi
}

git_init() {
    # print "git_init"
    typeset -ga chpwd_functions
    typeset -ga preexec_functions
    typeset -ga precmd_functions
    chpwd_functions+='git_chpwd_hook'
    preexec_functions+='git_preexec_hook'
    precmd_functions+='git_precmd_hook'
}

git_init
git_update_info